{"version":3,"sources":["DownloadManager.tsx","FragmentsToDownload.tsx","PlaybackManager.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["downloader","targets","inParallel","cb","progress","map","t","started","finished","target","Array","fill","forEach","fetchNext","remainingItems","filter","p","length","fetch","url","then","r","arrayBuffer","status","FragmentsToDownload","_","i","toString","padStart","n","durationMs","gallery","iteration","sequence","RAMP_TIME","TIMER_INVERTAL_SECONDS","audioContext","window","AudioContext","webkitAudioContext","defaultAppState","audioContextStatus","state","playbackStatus","appStateReducer","action","type","requestedIteration","App","useReducer","dispatch","completed","total","dispatchPlaybackRequest","useRef","useEffect","console","log","allPlaybackFragments","pm","fragments","TotalIterations","Math","max","apply","f","playerStateInternal","enqueue","request","source","createBufferSource","buffer","audioBuffer","gainNode","createGain","connect","destination","gain","setValueAtTime","startTime","exponentialRampToValueAtTime","start","offset","bufferDuration","duration","logicalStartTime","media","segment","node","audioDriverPublicState","pendingPlayerState","enqueueItemAfter","currentItem","disconnect","a","current","slice","whenToPlay","toPlayMedia","other","targetIteration","toPlay","byteLength","decodeAudioData","nextPlayerState","snapshotPlayingState","addEventListener","err","setInterval","currentMedia","currentTime","desiredChange","m","targetOffset","nextStartTime","desiredPlay","PlaybackManager","className","onClick","resume","src","style","gridArea","floor","key","JSON","stringify","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.1acda20f.chunk.js","sourcesContent":["type Downloadable = { url: string; arrayBuffer: ArrayBuffer | null };\n\nexport interface ItemProgress<T extends Downloadable> {\n  started: boolean;\n  finished: boolean;\n  target: T;\n}\n\ntype ProgressCallback<T extends Downloadable> = (p: ItemProgress<T>[]) => void;\nconst fetchNext: <T extends Downloadable>(\n  progress: ItemProgress<T>[],\n  cb: ProgressCallback<T>\n) => void = (progress, cb) => {\n  const remainingItems = progress.filter(p => !p.started);\n  if (remainingItems.length) {\n    remainingItems[0].started = true;\n    cb(progress);\n    fetch(remainingItems[0].target.url)\n      .then(r => r.arrayBuffer())\n      .then(r => {\n        remainingItems[0].finished = true;\n        remainingItems[0].target.arrayBuffer = r;\n        cb([...progress]);\n        fetchNext(progress, cb);\n      });\n  }\n};\n\ntype DownloaderType = <T extends Downloadable>(\n  targets: T[],\n  inParallel: number,\n  // TODO add a \"justInTime\" flag and convery the  \".target.arrayBuffer\" interface to async\n  // ... so that we can force pre-loading or allow for downloading on demand.\n  cb: (p: ItemProgress<T>[]) => void\n) => { status: () => ItemProgress<T>[] };\n\nexport const downloader: DownloaderType = (targets, inParallel, cb) => {\n  const progress = targets.map(t => ({\n    started: false,\n    finished: false,\n    target: t,\n  }));\n\n  Array(inParallel).fill(0).forEach(()=>fetchNext(progress, cb))\n\n  let status = () => progress;\n  const manager = {\n    status\n  };\n\n  return manager;\n};\n","import { AudioFragment } from \"./AudioFragment\";\nimport \"./App.css\";\n\nexport const FragmentsToDownload: AudioFragment[] = Array(9)\n  .fill(0)\n  .map((_, i) => (i).toString().padStart(2, \"0\"))\n  .map(n => `sitting/sitting.${n}.mp3`)\n  .map(\n    (url: string, i): AudioFragment => ({\n      url,\n      durationMs: 0,\n      gallery: \"coat-closet\",\n      iteration: i,\n      sequence: 0,\n      arrayBuffer: null\n    })\n  );\n","import { AudioFragment } from \"./AudioFragment\";\nimport { Gallery } from \"./Gallery\";\n\nconst RAMP_TIME = 0.1;\nconst TIMER_INVERTAL_SECONDS = 0.2;\n\ntype PlayerStateInternal = {\n  node: AudioBufferSourceNode;\n  gainNode: GainNode;\n  logicalStartTime: number;\n  media: AudioFragment;\n  bufferDuration: number;\n};\n\n\nexport default function PlaybackManager(\n  audioContext: AudioContext,\n  fragments: AudioFragment[],\n  cb: (pmStatus: PlaybackStatus) => void\n): PlaybackManager {\n  const TotalIterations = 1 + Math.max.apply(null, fragments.map(f => f.iteration));\n  let playerStateInternal: PlayerStateInternal[] = [];\n\n  const enqueue = (request: {\n    segment: AudioFragment;\n    startTime: number;\n    offset: number;\n    audioBuffer: AudioBuffer;\n  }): PlayerStateInternal => {\n    const source = audioContext.createBufferSource();\n    source.buffer = request.audioBuffer;\n\n    const gainNode = audioContext.createGain();\n    source.connect(gainNode);\n    gainNode.connect(audioContext.destination);\n    gainNode.gain.setValueAtTime(0.00000001, request.startTime);\n    gainNode.gain.exponentialRampToValueAtTime(\n      0.999,\n      request.startTime + RAMP_TIME\n    );\n    source.start(request.startTime, request.offset);\n    return {\n      bufferDuration: request.audioBuffer.duration,\n      logicalStartTime: request.startTime,\n      media: request.segment,\n      node: source,\n      gainNode: gainNode\n    };\n  };\n\n  let audioDriverPublicState: PlaybackStatus | null = null;\n  let pendingPlayerState: PlayerStateInternal | null = null;\n\n  const enqueueItemAfter = (currentItem: PlaybackItem) => {\n    if (pendingPlayerState) {\n      pendingPlayerState.node.disconnect();\n    }\n\n    const comesAfter = (a: AudioFragment) => (other: AudioFragment) => {\n      const targetIteration = (a.iteration + 1) % TotalIterations;\n      return other.iteration === targetIteration && other.gallery === a.gallery;\n    };\n\n    const current = playerStateInternal.slice(-1)[0];\n    const whenToPlay = current.logicalStartTime + current.bufferDuration;\n    const desiredOffset = 0;\n\n    let toPlayMedia = fragments.filter(comesAfter(current.media))[0];\n    let toPlay = toPlayMedia.arrayBuffer!;\n    toPlay = toPlay.slice(0, toPlay.byteLength);\n\n    audioContext.decodeAudioData(\n      toPlay,\n      audioBuffer => {\n        let nextPlayerState = enqueue({\n          segment: toPlayMedia,\n          startTime: whenToPlay,\n          offset: desiredOffset,\n          audioBuffer\n        });\n\n        pendingPlayerState = nextPlayerState;\n        const snapshotPlayingState = playerStateInternal;\n        current.node.addEventListener(\"ended\", () => {\n          if (snapshotPlayingState === playerStateInternal) {\n            playerStateInternal = [nextPlayerState];\n            pendingPlayerState = null;\n          }\n        });\n      },\n      err => {\n        console.log(\"Decode err\", err);\n      }\n    );\n  };\n\n  setInterval(() => {\n    if (!audioDriverPublicState) return;\n    if (playerStateInternal.length === 0) return;\n\n    // TODO save work here if 10x per second\n    const currentMedia = playerStateInternal.slice(-1)[0].media;\n\n    // TODO handle gallery changes too\n    if (currentMedia.iteration !== audioDriverPublicState.iteration) {\n      audioDriverPublicState = {\n        gallery: audioDriverPublicState.gallery,\n        iteration: currentMedia.iteration,\n        offset: 0\n      };\n      enqueueItemAfter(audioDriverPublicState);\n    }\n    cb({\n      ...audioDriverPublicState,\n      offset: audioContext.currentTime - playerStateInternal[0].logicalStartTime\n    });\n  }, TIMER_INVERTAL_SECONDS * 1000);\n\n  return {\n    dispatch: desiredChange => {\n      if (desiredChange.type !== \"change-iteration\") return;\n\n      if (\n        !audioDriverPublicState ||\n        audioDriverPublicState.iteration !== desiredChange.iteration\n      ) {\n        let toPlayMedia = fragments.filter(\n          m => m.iteration === desiredChange.iteration\n        )[0];\n\n        let toPlay = toPlayMedia.arrayBuffer!;\n\n        // (shallow) copy, because we can't decode\n        // the same === buffer while playing\n        toPlay = toPlay.slice(0, toPlay.byteLength);\n        audioContext.decodeAudioData(\n          toPlay,\n          audioBuffer => {\n            const targetOffset = playerStateInternal.length\n              ? audioContext.currentTime -\n                playerStateInternal.slice(-1)[0].logicalStartTime\n              : 0;\n\n            const nextStartTime = audioContext.currentTime + 0.1;\n            const nextPlayerState = enqueue({\n              segment: toPlayMedia,\n              startTime: nextStartTime,\n              offset: targetOffset,\n              audioBuffer\n            });\n\n            playerStateInternal.forEach(p => {\n              p.gainNode.gain.setValueAtTime(0.9999, nextStartTime);\n              p.gainNode.gain.exponentialRampToValueAtTime(\n                0.00001,\n                nextStartTime + RAMP_TIME * 3\n              );\n            });\n            playerStateInternal = [\n              {\n                node: nextPlayerState.node,\n                gainNode: nextPlayerState.gainNode,\n                logicalStartTime: audioContext.currentTime - targetOffset,\n                bufferDuration: audioBuffer.duration,\n                media: toPlayMedia\n              }\n            ];\n            const desiredPlay: PlaybackItem = {\n              iteration: desiredChange.iteration,\n              gallery: \"first-floor\" // TODO get from current public state\n            };\n\n            enqueueItemAfter(desiredPlay);\n            audioDriverPublicState = { ...desiredPlay, offset: 0 };\n          },\n          err => {\n            console.log(\"Decode err\", err);\n          }\n        );\n      }\n    }\n  };\n}\n\nexport type PlaybackRequest =\n  | { type: \"change-gallery\"; gallery: Gallery; }\n  | { type: \"change-iteration\"; iteration: number; };\n\nexport type PlaybackManager = {\n  dispatch: (p: PlaybackRequest) => void;\n};\n\nexport type PlaybackStatus = {\n  gallery: Gallery;\n  iteration: number;\n  offset: number;\n};\n\ntype PlaybackItem = {\n  [K in Exclude<keyof PlaybackStatus, \"offset\">]: PlaybackStatus[K];\n};\n","import React, { useEffect, useReducer, useRef } from \"react\";\nimport { ActionTypes } from \"./ActionTypes\";\nimport { AudioFragment } from \"./AudioFragment\";\nimport { downloader, ItemProgress } from \"./DownloadManager\";\nimport { FragmentsToDownload } from \"./FragmentsToDownload\";\nimport PlaybackManager, { PlaybackRequest, PlaybackStatus } from \"./PlaybackManager\";\n\nconst audioContext: AudioContext = new ((window as any).AudioContext ||\n  (window as any).webkitAudioContext)();\n\ntype AppState = {\n  progress: ItemProgress<AudioFragment>[];\n  audioContextStatus: string;\n  playbackStatus: PlaybackStatus;\n  requestedIteration?: number;\n};\n\nconst defaultAppState = {\n  progress: [],\n  audioContextStatus: audioContext.state,\n  playbackStatus: {} as PlaybackStatus\n};\n\nconst appStateReducer = (state: AppState, action: ActionTypes): AppState => {\n  switch (action.type) {\n    case \"requestIteration\":\n      return { ...state, requestedIteration: action.iteration};\n     case \"beginPlayback\":\n      return { ...state, audioContextStatus: audioContext.state };\n    case \"downloadStatus\":\n      return { ...state, progress: action.progress };\n    case \"playbackStatus\":\n      return { ...state, playbackStatus: action.status };\n    default:\n      return state;\n  }\n};\n\nconst PARALLEL_DOWNLOADS=3\n\nconst App: React.FC = () => {\n  const [state, dispatch] = useReducer(appStateReducer, defaultAppState);\n  const completed = state.progress.filter(p => p.finished).length;\n  const total = state.progress.length;\n\n  const dispatchPlaybackRequest = useRef((p: PlaybackRequest): void => {});\n  useEffect(() => {\n    console.log(\"DL\", FragmentsToDownload.length)\n    downloader(FragmentsToDownload, PARALLEL_DOWNLOADS, p =>\n      dispatch({\n        type: \"downloadStatus\",\n        progress: p\n      })\n    ); \n  }, []);\n\n  useEffect(() => {\n    const finishedItems = state.progress.filter(p => p.finished).length \n    if ( finishedItems < FragmentsToDownload.length)\n      return;\n\n    const allPlaybackFragments = state.progress.map(\n      (p: ItemProgress<AudioFragment>): AudioFragment => p.target\n    );\n\n    const pm = PlaybackManager(audioContext, allPlaybackFragments, status =>\n      dispatch({ type: \"playbackStatus\", status })\n    );\n\n    dispatchPlaybackRequest.current = pm.dispatch;\n  }, [state.progress]);\n\n  const startAudio = () => {\n    audioContext.resume().then(() => {\n      dispatch({ type: \"beginPlayback\" });\n    });\n  };\n\n  return (\n    <div className=\"App\">\n      <div className=\"wrapper\">\n      <header className=\"header\">\n        <button className=\"begin\" onClick={() => startAudio()}>Begin Playback</button>\n      </header>\n        {state.audioContextStatus === \"running\" &&\n          FragmentsToDownload.map((f,i) => (\n            <div className=\"iteration-box\">\n            <img className={`iteration \n              ${(f.iteration === state.playbackStatus.iteration) ? \"playing\" : \"\"}\n              ${(f.iteration === state.requestedIteration) ? \"requested\" : \"\"}\n              `} src=\"sitting.svg\" style={{\n              gridArea: `iteration${Math.floor(i/3)}${i%3}`\n            }}\n              key={f.iteration}\n              onClick={() => {\n                dispatch({type: \"requestIteration\", iteration: f.iteration})\n                dispatchPlaybackRequest.current({\n                  type: \"change-iteration\",\n                  iteration: f.iteration\n                })\n\n              }\n              }>\n            </img>\n            </div>\n          ))}\n        \n        <br></br>\n        <pre>{JSON.stringify(state.playbackStatus, null, 2)}</pre>\n      <footer className=\"footer\">\n        <pre>\n          {completed} of {total} files loaded.  \n          {\" \" + state.audioContextStatus}. \n          Chazen ＆ cetera. 2020.\n        </pre>\n        </footer>\n     </div> \n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}