{"version":3,"sources":["DownloadManager.tsx","FragmentsToDownload.tsx","PlaybackManager.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["downloader","targets","cb","progress","map","t","started","finished","target","fetchNext","todo","filter","p","length","fetch","url","then","r","arrayBuffer","status","FragmentsToDownload","Array","fill","_","i","toString","padStart","n","durationMs","gallery","iteration","sequence","RAMP_TIME","TIMER_INVERTAL_SECONDS","audioContext","window","AudioContext","webkitAudioContext","defaultAppState","audioContextStatus","state","playbackStatus","appStateReducer","action","type","App","useReducer","dispatch","completed","total","dispatchPlaybackRequest","useRef","useEffect","console","log","allPlaybackFragments","pm","fragments","TotalIterations","Math","max","apply","f","playerStateInternal","enqueue","request","source","createBufferSource","buffer","audioBuffer","gainNode","createGain","connect","destination","gain","setValueAtTime","startTime","exponentialRampToValueAtTime","start","offset","bufferDuration","duration","logicalStartTime","media","segment","node","audioDriverPublicState","pendingPlayerState","enqueueItemAfter","currentItem","disconnect","a","current","slice","whenToPlay","toPlayMedia","other","targetIteration","toPlay","byteLength","decodeAudioData","nextPlayerState","snapshotPlayingState","addEventListener","err","setInterval","currentMedia","currentTime","desiredChange","m","targetOffset","nextStartTime","forEach","desiredPlay","PlaybackManager","className","onClick","resume","key","JSON","stringify","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.4ca102f5.chunk.js","sourcesContent":["type Downloadable = { url: string; arrayBuffer: ArrayBuffer | null };\n\nexport interface ItemProgress<T extends Downloadable> {\n  started: boolean;\n  finished: boolean;\n  target: T;\n}\n\ntype ProgressCallback<T extends Downloadable> = (p: ItemProgress<T>[]) => void;\nconst fetchNext: <T extends Downloadable>(\n  progress: ItemProgress<T>[],\n  cb: ProgressCallback<T>\n) => void = (progress, cb) => {\n  const todo = progress.filter(p => !p.started);\n  if (todo.length) {\n    todo[0].started = true;\n    cb(progress);\n    fetch(todo[0].target.url)\n      .then(r => r.arrayBuffer())\n      .then(r => {\n        todo[0].finished = true;\n        todo[0].target.arrayBuffer = r;\n        cb([...progress]);\n        fetchNext(progress, cb);\n      });\n  }\n};\n\ntype DownloaderType = <T extends Downloadable>(\n  targets: T[],\n  // TODO add a \"justInTime\" flag and convery the  \".target.arrayBuffer\" interface to async\n  // ... so that we can force pre-loading or allow for downloading on demand.\n  cb: (p: ItemProgress<T>[]) => void\n) => { status: () => ItemProgress<T>[] };\n\nexport const downloader: DownloaderType = (targets, cb) => {\n  const progress = targets.map(t => ({\n    started: false,\n    finished: false,\n    target: t,\n  }));\n  fetchNext(progress, cb);\n\n  let status = () => progress;\n  const manager = {\n    status\n  };\n\n  return manager;\n};\n","import { AudioFragment } from \"./AudioFragment\";\n\nexport const FragmentsToDownload: AudioFragment[] = Array(10 * 3 * 4)\n  .fill(0)\n  .map((_, i) => (i%10).toString().padStart(2, \"0\"))\n  .map(n => `sitting/sitting.${n}.mp3`)\n  .map(\n    (url: string, i): AudioFragment => ({\n      url,\n      durationMs: 0,\n      gallery: \"coat-closet\",\n      iteration: i,\n      sequence: 0,\n      arrayBuffer: null\n    })\n  );\n","import { AudioFragment } from \"./AudioFragment\";\nimport { Gallery } from \"./Gallery\";\n\nconst RAMP_TIME = 0.1;\nconst TIMER_INVERTAL_SECONDS = 0.2;\n\ntype PlayerStateInternal = {\n  node: AudioBufferSourceNode;\n  gainNode: GainNode;\n  logicalStartTime: number;\n  media: AudioFragment;\n  bufferDuration: number;\n};\n\n\nexport default function PlaybackManager(\n  audioContext: AudioContext,\n  fragments: AudioFragment[],\n  cb: (pmStatus: PlaybackStatus) => void\n): PlaybackManager {\n  const TotalIterations = 1 + Math.max.apply(null, fragments.map(f => f.iteration));\n  let playerStateInternal: PlayerStateInternal[] = [];\n\n  const enqueue = (request: {\n    segment: AudioFragment;\n    startTime: number;\n    offset: number;\n    audioBuffer: AudioBuffer;\n  }): PlayerStateInternal => {\n    const source = audioContext.createBufferSource();\n    source.buffer = request.audioBuffer;\n\n    const gainNode = audioContext.createGain();\n    source.connect(gainNode);\n    gainNode.connect(audioContext.destination);\n    gainNode.gain.setValueAtTime(0.00000001, request.startTime);\n    gainNode.gain.exponentialRampToValueAtTime(\n      0.999,\n      request.startTime + RAMP_TIME\n    );\n    source.start(request.startTime, request.offset);\n    return {\n      bufferDuration: request.audioBuffer.duration,\n      logicalStartTime: request.startTime,\n      media: request.segment,\n      node: source,\n      gainNode: gainNode\n    };\n  };\n\n  let audioDriverPublicState: PlaybackStatus | null = null;\n  let pendingPlayerState: PlayerStateInternal | null = null;\n\n  const enqueueItemAfter = (currentItem: PlaybackItem) => {\n    if (pendingPlayerState) {\n      pendingPlayerState.node.disconnect();\n    }\n\n    const comesAfter = (a: AudioFragment) => (other: AudioFragment) => {\n      const targetIteration = (a.iteration + 1) % TotalIterations;\n      return other.iteration === targetIteration && other.gallery === a.gallery;\n    };\n\n    const current = playerStateInternal.slice(-1)[0];\n    const whenToPlay = current.logicalStartTime + current.bufferDuration;\n    const desiredOffset = 0;\n\n    let toPlayMedia = fragments.filter(comesAfter(current.media))[0];\n    let toPlay = toPlayMedia.arrayBuffer!;\n    toPlay = toPlay.slice(0, toPlay.byteLength);\n\n    audioContext.decodeAudioData(\n      toPlay,\n      audioBuffer => {\n        let nextPlayerState = enqueue({\n          segment: toPlayMedia,\n          startTime: whenToPlay,\n          offset: desiredOffset,\n          audioBuffer\n        });\n\n        pendingPlayerState = nextPlayerState;\n        const snapshotPlayingState = playerStateInternal;\n        current.node.addEventListener(\"ended\", () => {\n          if (snapshotPlayingState === playerStateInternal) {\n            playerStateInternal = [nextPlayerState];\n            pendingPlayerState = null;\n          }\n        });\n      },\n      err => {\n        console.log(\"Decode err\", err);\n      }\n    );\n  };\n\n  setInterval(() => {\n    if (!audioDriverPublicState) return;\n    if (playerStateInternal.length === 0) return;\n\n    // TODO save work here if 10x per second\n    const currentMedia = playerStateInternal.slice(-1)[0].media;\n\n    // TODO handle gallery changes too\n    if (currentMedia.iteration !== audioDriverPublicState.iteration) {\n      audioDriverPublicState = {\n        gallery: audioDriverPublicState.gallery,\n        iteration: currentMedia.iteration,\n        offset: 0\n      };\n      enqueueItemAfter(audioDriverPublicState);\n    }\n    cb({\n      ...audioDriverPublicState,\n      offset: audioContext.currentTime - playerStateInternal[0].logicalStartTime\n    });\n  }, TIMER_INVERTAL_SECONDS * 1000);\n\n  return {\n    dispatch: desiredChange => {\n      if (desiredChange.type !== \"change-iteration\") return;\n\n      if (\n        !audioDriverPublicState ||\n        audioDriverPublicState.iteration !== desiredChange.iteration\n      ) {\n        let toPlayMedia = fragments.filter(\n          m => m.iteration === desiredChange.iteration\n        )[0];\n\n        let toPlay = toPlayMedia.arrayBuffer!;\n\n        // (shallow) copy, because we can't decode\n        // the same === buffer while playing\n        toPlay = toPlay.slice(0, toPlay.byteLength);\n        audioContext.decodeAudioData(\n          toPlay,\n          audioBuffer => {\n            const targetOffset = playerStateInternal.length\n              ? audioContext.currentTime -\n                playerStateInternal.slice(-1)[0].logicalStartTime\n              : 0;\n\n            const nextStartTime = audioContext.currentTime + 0.1;\n            const nextPlayerState = enqueue({\n              segment: toPlayMedia,\n              startTime: nextStartTime,\n              offset: targetOffset,\n              audioBuffer\n            });\n\n            playerStateInternal.forEach(p => {\n              p.gainNode.gain.setValueAtTime(0.9999, nextStartTime);\n              p.gainNode.gain.exponentialRampToValueAtTime(\n                0.00001,\n                nextStartTime + RAMP_TIME * 3\n              );\n            });\n            playerStateInternal = [\n              {\n                node: nextPlayerState.node,\n                gainNode: nextPlayerState.gainNode,\n                logicalStartTime: audioContext.currentTime - targetOffset,\n                bufferDuration: audioBuffer.duration,\n                media: toPlayMedia\n              }\n            ];\n            const desiredPlay: PlaybackItem = {\n              iteration: desiredChange.iteration,\n              gallery: \"first-floor\" // TODO get from current public state\n            };\n\n            enqueueItemAfter(desiredPlay);\n            audioDriverPublicState = { ...desiredPlay, offset: 0 };\n          },\n          err => {\n            console.log(\"Decode err\", err);\n          }\n        );\n      }\n    }\n  };\n}\n\nexport type PlaybackRequest =\n  | { type: \"change-gallery\"; gallery: Gallery; }\n  | { type: \"change-iteration\"; iteration: number; };\n\nexport type PlaybackManager = {\n  dispatch: (p: PlaybackRequest) => void;\n};\n\nexport type PlaybackStatus = {\n  gallery: Gallery;\n  iteration: number;\n  offset: number;\n};\n\ntype PlaybackItem = {\n  [K in Exclude<keyof PlaybackStatus, \"offset\">]: PlaybackStatus[K];\n};\n","import React, { useEffect, useReducer, useRef } from \"react\";\nimport { ActionTypes } from \"./ActionTypes\";\nimport { AudioFragment } from \"./AudioFragment\";\nimport { downloader, ItemProgress } from \"./DownloadManager\";\nimport { FragmentsToDownload } from \"./FragmentsToDownload\";\nimport PlaybackManager, { PlaybackRequest, PlaybackStatus } from \"./PlaybackManager\";\n\nconst audioContext: AudioContext = new ((window as any).AudioContext ||\n  (window as any).webkitAudioContext)();\n\ntype AppState = {\n  progress: ItemProgress<AudioFragment>[];\n  audioContextStatus: string;\n  playbackStatus: PlaybackStatus;\n};\n\nconst defaultAppState = {\n  progress: [],\n  audioContextStatus: audioContext.state,\n  playbackStatus: {} as PlaybackStatus\n};\n\nconst appStateReducer = (state: AppState, action: ActionTypes): AppState => {\n  switch (action.type) {\n    case \"beginPlayback\":\n      return { ...state, audioContextStatus: audioContext.state };\n    case \"downloadStatus\":\n      return { ...state, progress: action.progress };\n    case \"playbackStatus\":\n      return { ...state, playbackStatus: action.status };\n    default:\n      return state;\n  }\n};\n\nconst App: React.FC = () => {\n  const [state, dispatch] = useReducer(appStateReducer, defaultAppState);\n  const completed = state.progress.filter(p => p.finished).length;\n  const total = state.progress.length;\n\n  const dispatchPlaybackRequest = useRef((p: PlaybackRequest): void => {});\n  useEffect(() => {\n    console.log(\"DL\", FragmentsToDownload.length)\n    downloader(FragmentsToDownload, p =>\n      dispatch({\n        type: \"downloadStatus\",\n        progress: p\n      })\n    );\n  }, []);\n\n  useEffect(() => {\n    const finishedItems = state.progress.filter(p => p.finished).length \n    if ( finishedItems < FragmentsToDownload.length)\n      return;\n\n    const allPlaybackFragments = state.progress.map(\n      (p: ItemProgress<AudioFragment>): AudioFragment => p.target\n    );\n\n    const pm = PlaybackManager(audioContext, allPlaybackFragments, status =>\n      dispatch({ type: \"playbackStatus\", status })\n    );\n\n    dispatchPlaybackRequest.current = pm.dispatch;\n  }, [state.progress]);\n\n  const startAudio = () => {\n    console.log(\"Starting audio\", audioContext);\n    audioContext.resume().then(() => {\n      dispatch({ type: \"beginPlayback\" });\n    });\n  };\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <button onClick={() => startAudio()}>Begin Playback</button>\n        {state.audioContextStatus === \"running\" &&\n          FragmentsToDownload.map(f => (\n            <button\n              key={f.iteration}\n              onClick={() =>\n                dispatchPlaybackRequest.current({\n                  type: \"change-iteration\",\n                  iteration: f.iteration\n                })\n              }>\n              {f.iteration}\n            </button>\n          ))}\n        <pre>\n          {completed} of {total} files loaded.\n          {state.audioContextStatus}\n        </pre>\n        <br></br>\n        <pre>{JSON.stringify(state.playbackStatus, null, 2)}</pre>\n      </header>\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}