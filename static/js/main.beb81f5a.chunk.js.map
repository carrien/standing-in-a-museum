{"version":3,"sources":["ActionTypes.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Gallery","window","AudioContext","webkitAudioContext","GalleryNames","study","court","niche","bridge","defaultGalleryParam","location","hash","slice","defaultAppState","iteration","gallery","Object","keys","includes","appStateReducer","state","action","type","App","useReducer","dispatch","audioElements","useRef","className","map","ref","preload","controls","src","c","i","String","padStart","gridArea","Math","floor","style","key","onClick","filter","forEach","g","console","log","current","pause","play","currentTime","description","atTime","Boolean","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.beb81f5a.chunk.js","sourcesContent":["import { AudioFragment } from \"./AudioFragment\";\nimport { ItemProgress } from \"./DownloadManager\";\nimport { PlaybackStatus } from \"./PlaybackManager\";\n\nexport enum Gallery {\n  study,\n  court,\n  niche,\n  bridge,\n}\n\n\nexport type ActionTypes =\n  | { type: \"beginPlayback\" }\n  | { type: \"pickIteration\"; selectedIteration: number }\n  | { type: \"pickTime\"; subtype: \"a\"; selectedTime: number }\n  | { type: \"downloadStatus\"; progress: ItemProgress<AudioFragment>[] }\n  | { type: \"playbackStatus\"; status: PlaybackStatus }\n  | { type: \"requestGallery\"; gallery: Gallery }\n  | { type: \"requestIteration\"; iteration: number }\n  | { type: \"rollOverToIteration\"; iteration: number };\n","import React, { useEffect, useReducer, useRef } from \"react\";\nimport { ActionTypes, Gallery } from \"./ActionTypes\";\nimport \"./App.css\"\n\nconst audioContext: AudioContext = new ((window as any).AudioContext ||\n  (window as any).webkitAudioContext)();\n\n\nconst GalleryNames: [string, Gallery][] = [\n  [\"Objects Study Room\", Gallery.study],\n  [\"Paige Court\", Gallery.court],\n  [\"Japanese Niche\", Gallery.niche],\n  [\"Bridge\", Gallery.bridge],\n]\n\nconst defaultGalleryParam = window.location.hash.slice(1);\n\nconst defaultGallery: Gallery = Object.keys(Gallery).includes(defaultGalleryParam) ?\n  (Gallery as any)[defaultGalleryParam] : Gallery.niche;\n\ntype AppState = {\n  iteration: number;\n  gallery: Gallery\n};\n\nconst defaultAppState: AppState = {\n  iteration: 0,\n  gallery: defaultGallery\n};\n\nconst appStateReducer = (state: AppState, action: ActionTypes): AppState => {\n  switch (action.type) {\n    case \"requestGallery\":\n      return { ...state, gallery: action.gallery};\n     case \"requestIteration\":\n      return { ...state, iteration: action.iteration || 0 };\n    case \"rollOverToIteration\":\n      return { ...state, iteration: action.iteration || 0 };\n    default:\n      return state;\n  }\n};\n\nconst PARALLEL_DOWNLOADS = 3\n\nconst App: React.FC = () => {\n  const [state, dispatch] = useReducer(appStateReducer, defaultAppState);\n\n  const audioElements: Record<Gallery, any> = {\n    [Gallery.study]: useRef<HTMLAudioElement>(null),\n    [Gallery.court]: useRef<HTMLAudioElement>(null),\n    [Gallery.niche]: useRef<HTMLAudioElement>(null),\n    [Gallery.bridge]: useRef<HTMLAudioElement>(null)\n  };\n\n  const ITERATION_DURATION = 64.32 // 76;\n  const LOOKBACK_ON_SWITCH = 0;\n  const iterationList: [number, string][] = [\n    [0, \"sitting.01.png\"],\n    [1, \"sitting.02.png\"],\n    [2, \"sitting.03.png\"],\n    [3, \"sitting.04.png\"],\n    [4, \"sitting.01.png\"],\n    [5, \"sitting.02.png\"],\n    [6, \"sitting.03.png\"],\n    [7, \"sitting.04.png\"],\n    [8, \"sitting.01.png\"],\n    [9, \"sitting.02.png\"],\n    [10, \"sitting.03.png\"],\n    [11, \"sitting.04.png\"],\n    [12, \"sitting.01.png\"],\n    [13, \"sitting.02.png\"],\n    [13, \"sitting.03.png\"],\n    [15, \"sitting.04.png\"],\n  ]\n\n  // iteration_duration = 64.32s\n  return (\n    <div className=\"App\">\n      <div className=\"wrapper\">\n        <header className=\"header\">\n          {GalleryNames.map(([description, gallery]) => (\n            <audio ref={audioElements[gallery]} preload=\"auto\" controls src={`${Gallery[gallery]}.mp3`} className=\"begin\" />\n          ))}\n        </header>\n        {iterationList.map(([i, icon], c) => {\n          \n          const src = `icon-${Gallery[state.gallery]}-${String(c).padStart(2, '0')}.svg`\n          const gridArea = `iteration${Math.floor(c / 4)}${c % 4}`\n          const className = `iteration \n                ${state.iteration === i ? \"playing\" : \"\"}\n                gallery-${state.gallery}\n              `;\n\n          return (\n          <img className={className} src={src} style={{ gridArea }}\n            key={c}\n            onClick={() => {\n              GalleryNames.filter(([desc,g]) => g!== state.gallery).forEach(([desc,g]) => \n              {\n                console.log(\"For \", g, \"!-\", typeof state.gallery, \"pausing\");\n                audioElements[g].current!.pause()\n              })\n              audioElements[state.gallery].current!.play()\n              audioElements[state.gallery].current!.currentTime = ((audioElements[state.gallery].current!.currentTime - LOOKBACK_ON_SWITCH) % ITERATION_DURATION) + c * ITERATION_DURATION\n              dispatch({\n                type: \"requestIteration\",\n                iteration: i\n              })\n            }\n            }>\n          </img>\n        )}\n        )}\n        <footer className=\"footer\">\n          <div className=\"gallery-selection\">\n            {GalleryNames.map(([description, gallery]) => (\n              <button\n              key={gallery} \n              onClick={() => {\n                dispatch({\n                  type: \"requestGallery\",\n                  gallery\n                })\n                const atTime = audioElements[state.gallery].current!.currentTime;\n                GalleryNames.forEach(([desc,g]) => \n                {\n                  console.log(\"new galFor \", g, \"!-\", typeof state.gallery, \"pausing\");\n                  g !== gallery && audioElements[g].current!.pause()\n                })\n                  audioElements[gallery].current!.currentTime = atTime + .010;\n                  audioElements[gallery].current!.play()\n                console.log(\"Dine stet\", atTime)\n              }}\n              className={`\n                ${state.gallery == gallery ? \"selected\" : \"default\"}\n                ${Gallery[state.gallery]}\n              `}>{description}</button>\n            ))}\n          </div>\n          Chazen et cetera. 2020.\n        </footer>\n      </div>\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}